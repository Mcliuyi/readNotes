# 高性能MySQL

## 1. MySQL架构与历史

### 1.1 三层架构

#####  第一层

​	客户端，用于处理连接，权限认证等

##### 第二层

​	服务层，内置函数以及查询解析，分析，优化，缓存均在此层。

​	所有跨引擎的功能均在此层,如: 存储过程，触发器，视图等等

##### 第三层

​	引擎层， 负责数据的存储和提取，每种不同的引擎有不同的优缺点，服务器通过API	调用的形式与引擎进行通信，但是底层引擎不会主动解析SQL(InnoDB除外,因为服务器本身不带有外键定义的功能)，引擎之间**互不干涉**

![MySQL架构图](https://ly-markdown.oss-cn-shenzhen.aliyuncs.com/MySQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

#### 1.1.1 连接管理与安全性

​	每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询仅会在单独的线程中执行。服务器会负责新建与摧毁这些线程。

#### 1.1.2 优化与执行

​	服务器在执行一条SQL语句是会先去缓存查询，如果存在则之间返回缓存中的结果集，否则将对SQL语句进行解析优化。

### 1.2 并发控制

   如何处理**多个查询在同一时刻对一条数据进行修改**，以保证数据的**安全性与一致性**

#### 1.2.1 读写锁

​	读写锁通常称为, **共享锁(shared lock)**，**排他锁(exclusive lock)**, 也可以称为**读锁(read lock)**，**写锁(write lock)**

- 共享锁

  同一时刻允许多个客户端访问资源

- 写锁

  同一时刻只允许一个用户对上锁资源进行写入

#### 1.2.2 锁粒度

​	由于锁的各种是需要消耗系统资源，所以根据需求对部分数据进行锁定，可以提高系统的并发量，**锁定的资源越少，系统并发越高，只要相互之间不发生冲突即可**。

​	每种不同MySQL存储引擎都实现了属于自己的锁策略和锁粒度。

​	主要的两种锁策略, **表锁**(table lock)，**行级锁(row lock)**

- **表锁**

  MySQL中最基本的锁策略，并且是**开销最小的策略**，表锁会锁定整张表，一个用户在对表做**写入操作**是必须要先获取**写锁**，同时会**阻塞**其他所有用户对该表的**读写操作**，只有当这张表**不存在写锁**时，才能获取**读锁**，读锁之间**不相互堵塞**

- **行级锁**

  行级锁可以最大程度的支持并发操作，同时也带来了**最大的锁开销**，**行级锁只存在存储引擎中**。

### 1.3 事务

​	事务就是**一组原子性**的SQL查询，或者说一个独立的工作单元，只有当事务中的**所有语句都执行成功**，该组查询才会成功，如果有**任何一条**语句失败, 那么该组查询失败。意思是要么都成功，要么都失败

事务的四大特性简称为**ACID**: 

- **原子性(atomicity)**

  事务必须是**最小的执行单元**，意思要么事务内语句全部成功，要么全部失败，不能只执行一部分语句

- **一致性(consistency)**

  如果事务执行失败, 那么事务不会修改任何一条数据，与开始执行事务时保持数据一致, 同时只要事务不提交，在事务期间执行的语句不会真正的对数据生效

- **隔离性(isolation)**

  事务在执行过程中，**其他事务是不可见的**。意思是在一个事务执行过程中，对数据进行的操作，其他事务都不可见，不知道，不知情

- **持久性(durability)**

  **一旦事务提交**，所做的修改便会永久保存在数据库中，即使此时服务崩溃。
# 高性能MySQL

## 1. MySQL架构与历史

### 1.1 三层架构

#####  第一层

​	客户端，用于处理连接，权限认证等

##### 第二层

​	服务层，内置函数以及查询解析，分析，优化，缓存均在此层。

​	所有跨引擎的功能均在此层,如: 存储过程，触发器，视图等等

##### 第三层

​	引擎层， 负责数据的存储和提取，每种不同的引擎有不同的优缺点，服务器通过API	调用的形式与引擎进行通信，但是底层引擎不会主动解析SQL(InnoDB除外,因为服务器本身不带有外键定义的功能)，引擎之间**互不干涉**

![MySQL架构图](https://ly-markdown.oss-cn-shenzhen.aliyuncs.com/MySQL%E6%9E%B6%E6%9E%84%E5%9B%BE.png)

#### 1.1.1 连接管理与安全性

​	每个客户端连接都会在服务器进程中拥有一个线程，这个连接的查询仅会在单独的线程中执行。服务器会负责新建与摧毁这些线程。

#### 1.1.2 优化与执行

​	服务器在执行一条SQL语句是会先去缓存查询，如果存在则之间返回缓存中的结果集，否则将对SQL语句进行解析优化。

### 1.2 并发控制

   如何处理**多个查询在同一时刻对一条数据进行修改**，以保证数据的**安全性与一致性**

#### 1.2.1 读写锁

​	读写锁通常称为, **共享锁(shared lock)**，**排他锁(exclusive lock)**, 也可以称为**读锁(read lock)**，**写锁(write lock)**

- 共享锁

  同一时刻允许多个客户端访问资源

- 写锁

  同一时刻只允许一个用户对上锁资源进行写入

#### 1.2.2 锁粒度

​	由于锁的各种是需要消耗系统资源，所以根据需求对部分数据进行锁定，可以提高系统的并发量，**锁定的资源越少，系统并发越高，只要相互之间不发生冲突即可**。

​	每种不同MySQL存储引擎都实现了属于自己的锁策略和锁粒度。

​	主要的两种锁策略, **表锁**(table lock)，**行级锁(row lock)**

- **表锁**

  MySQL中最基本的锁策略，并且是**开销最小的策略**，表锁会锁定整张表，一个用户在对表做**写入操作**是必须要先获取**写锁**，同时会**阻塞**其他所有用户对该表的**读写操作**，只有当这张表**不存在写锁**时，才能获取**读锁**，读锁之间**不相互堵塞**

- **行级锁**

  行级锁可以最大程度的支持并发操作，同时也带来了**最大的锁开销**，**行级锁只存在存储引擎中**。

### 1.3 事务



​	事务就是**一组原子性**的SQL查询，或者说一个独立的工作单元，只有当事务中的**所有语句都执行成功**，该组查询才会成功，如果有**任何一条**语句失败, 那么该组查询失败。意思是要么都成功，要么都失败

事务的四大特性简称为**ACID**: 

- **原子性(atomicity)**

  事务必须是**最小的执行单元**，意思要么事务内语句全部成功，要么全部失败，不能只执行一部分语句

- **一致性(consistency)**

  如果事务执行失败, 那么事务不会修改任何一条数据，与开始执行事务时保持数据一致, 同时只要事务不提交，在事务期间执行的语句不会真正的对数据生效

- **隔离性(isolation)**

  事务在执行过程中，**其他事务是不可见的**。意思是在一个事务执行过程中，对数据进行的操作，其他事务都不可见，不知道，不知情

- **持久性(durability)**

  **一旦事务提交**，所做的修改便会永久保存在数据库中，即使此时服务崩溃。

#### 1.3.1 隔离级别

​		不同的隔离级别，在事务内的可见性不同，开销也不同，级别越低的，可以执行更高的并发，开销也越低

- **READ UNCOMMITTED(未提交读)**

  在事务未提交做的修改，其他事务依旧可以查看未提交事务做的数据修改，称为脏读。不建议使用

- **READ COMMITED(提交读)**

  事务未提交前做的修改，对其它事务不可见。称为不可重复读，因为可能两次的查询结果不一

- **REPEATABLE READ(可重复读)**

  保证同一个事务中多次查询的数据一致，但是无法解决**幻读**，**幻读**意识是在某个事务读取某个范围内数据时，其他事务在此数据中间插入了新的数据，此时上一个事务再次查询时会产生**幻行**

- **SERIALIZABLE(可串行化)**

  最高的隔离级别，强制事务串行，简单的说就是在读区的每一行数据都进行加锁，所以会导致大量的超时和锁争用的。

隔离级表

| 隔离级别         | 脏读可能性 | 不可重复读可能性 | 幻读可能性 | 加锁读 |
| ---------------- | ---------- | ---------------- | ---------- | ------ |
| READ UNCOMMITTED | Yes        | Yes              | Yes        | No     |
| READ COMMITTED   | No         | Yes              | Yes        | No     |
| REPEATABLE READ  | No         | No               | Yes        | No     |
| SERIALIZABLE     | No         | No               | No         | Yes    |



#### 1.3.2 死锁

​		死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方占用资源，从而导致恶性循环。

​		锁的行为和顺序和存储引擎相关，同样的执行顺序，在有些引擎会产生死锁，有些不会。产生死锁有双重原因：有些是因为数据冲突，这种情况通常难以避免，但有些则完全是由于存储引擎实现方式导致。死锁发生后只有将部分或者完全回滚一个事务，才能打破死锁





















